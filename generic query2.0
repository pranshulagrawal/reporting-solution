-- This script is adapted for very old versions of Sybase ASE.
-- It uses variables to dynamically filter for a specific number of past days (e.g., 7, 30, 90).

-- ====================================================================
--  Configuration: Set the number of days for the filter period here
-- ====================================================================
DECLARE @NumDays INT
SET @NumDays = 7 -- Change to 30 or 90 for different time windows

-- ====================================================================
--  Variable Declaration: Do not edit below this line
-- ====================================================================
DECLARE @StartDate DATETIME
DECLARE @EndDate DATETIME
DECLARE @Today_YYYYMMDD VARCHAR(8)
DECLARE @T_Minus_1_BusinessDay DATETIME
DECLARE @DayOfWeek INT

-- Determine the T-1 business day, accounting for weekends.
SET @DayOfWeek = DATEPART(dw, GETDATE())
IF @DayOfWeek = 2 -- If today is Monday, T-1 is Friday (-3 days)
    SET @T_Minus_1_BusinessDay = DATEADD(day, -3, GETDATE())
ELSE IF @DayOfWeek = 1 -- If today is Sunday, T-1 is Friday (-2 days)
    SET @T_Minus_1_BusinessDay = DATEADD(day, -2, GETDATE())
ELSE -- For any other day (Tuesday to Saturday), T-1 is the previous day
    SET @T_Minus_1_BusinessDay = DATEADD(day, -1, GETDATE())

-- Calculate the start and end dates based on @NumDays, using the T-1 business day as the reference point.
SET @StartDate = CONVERT(DATETIME, CONVERT(VARCHAR, DATEADD(day, -(@NumDays - 1), @T_Minus_1_BusinessDay), 112))
SET @EndDate = CONVERT(DATETIME, CONVERT(VARCHAR, DATEADD(day, 1, @T_Minus_1_BusinessDay), 112))
SET @Today_YYYYMMDD = CONVERT(VARCHAR, @T_Minus_1_BusinessDay, 112)


-- 1. Query for KPI Cards (Using scalar subqueries to avoid CASE)
SELECT
    (SELECT COUNT(*) FROM break_data b WHERE CONVERT(VARCHAR, b.created_at, 112) = @Today_YYYYMMDD) AS todaysBreaks,
    (SELECT COUNT(*) FROM break_data b WHERE b.status != 'Resolved' AND b.ageing > 5 AND b.created_at >= @StartDate AND b.created_at < @EndDate) AS agedBreaks,
    (SELECT COUNT(*) FROM break_data b WHERE b.status != 'Resolved' AND b.created_at >= @StartDate AND b.created_at < @EndDate) AS openBreaks,
    (CAST((SELECT COUNT(*) FROM break_data b WHERE b.status = 'Resolved' AND b.created_at >= @StartDate AND b.created_at < @EndDate) AS DECIMAL(10,2)) * 100 / (SELECT COUNT(*) FROM break_data b WHERE b.created_at >= @StartDate AND b.created_at < @EndDate)) AS resolvedPercentage;

-- 2. Query for "Break Trends" Line Chart (No CASE statement, no change needed)
SELECT
    CONVERT(VARCHAR(12), b.created_at, 107) AS name, -- Format: Mon dd, yyyy
    COUNT(*) AS breaks
FROM
    break_data b
WHERE
    b.created_at >= @StartDate AND b.created_at < @EndDate
GROUP BY
    CONVERT(VARCHAR(12), b.created_at, 107)
ORDER BY
    MIN(b.created_at) ASC;

-- 3. Query for "Breaks by Category" Pie Chart (No CASE statement, no change needed)
SELECT
    bc.name,
    COUNT(b.id) AS value
FROM
    break_data b,
    break_category bc
WHERE
    b.break_category_ref = bc.id
AND
    b.created_at >= @StartDate AND b.created_at < @EndDate
GROUP BY
    bc.name;

-- 4. Query for "Assignee Health" Panel (Using correlated subqueries to avoid CASE)
SELECT
    distinct_assignees.assignee AS name,
    (SELECT COUNT(*) FROM break_data b WHERE b.assignee = distinct_assignees.assignee AND b.status = 'Open' AND b.created_at >= @StartDate AND b.created_at < @EndDate) AS open,
    (SELECT COUNT(*) FROM break_data b WHERE b.assignee = distinct_assignees.assignee AND b.status = 'Resolved' AND b.created_at >= @StartDate AND b.created_at < @EndDate) AS resolved,
    (SELECT COUNT(*) FROM break_data b WHERE b.assignee = distinct_assignees.assignee AND b.created_at >= @StartDate AND b.created_at < @EndDate) AS value
FROM
    (SELECT DISTINCT assignee FROM break_data WHERE created_at >= @StartDate AND created_at < @EndDate) AS distinct_assignees;

-- 5. Query for the "Break Details" Table (No CASE statement, no change needed)
SELECT TOP 5
    b.id,
    bc.name AS category,
    bsc.name AS subCategory,
    b.assignee,
    b.status,
    b.ageing
FROM
    break_data b,
    break_category bc,
    break_subcategory bsc
WHERE
    b.break_category_ref *= bc.id
AND
    b.sub_cat_ref *= bsc.id
AND
    b.created_at >= @StartDate AND b.created_at < @EndDate
ORDER BY
    b.created_at DESC;
